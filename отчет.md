# Техническая документация платформы бронирования экскурсий

## Введение

Серверная часть приложения реализована на языке PHP с использованием расширения PDO (PHP Data Objects), что позволяет обеспечить безопасную и универсальную работу с реляционной базой данных MySQL. Использование подготовленных выражений (prepared statements) снижает риск SQL-инъекций и повышает надёжность системы. Клиентская часть разработана с применением HTML, CSS и JavaScript, что обеспечивает адаптивный интерфейс и динамическое взаимодействие с сервером без полной перезагрузки страниц.

Для удобства разработки и логического разделения компонентов проекта была сформирована следующая структура каталогов:

- **config/** – конфигурационные файлы приложения (настройки базы данных, маршрутизация, пути к ресурсам)
- **includes/** – серверная логика, модули обработки данных (авторизация, обработка бронирований, управление экскурсиями)
- **api/** – REST-подобные API-эндпоинты для асинхронных запросов
- **pages/** – страницы пользовательского интерфейса (регистрация, вход, просмотр экскурсий, личные кабинеты)
- **css/** – каскадные таблицы стилей для оформления интерфейса
- **js/** – клиентские скрипты для интерактивности
- **uploads/** – каталог для загружаемых файлов (изображения экскурсий, аватары пользователей)
- **sql/** – SQL-скрипты для создания и миграции базы данных

Такая организация проекта соответствует лучшим практикам веб-разработки и способствует повышению качества итогового программного продукта. Модульная структура обеспечивает простоту поддержки и расширения функционала платформы.

## Архитектура системы

### Конфигурация приложения

Основные настройки приложения находятся в файле `config/app.php`. Данный файл определяет базовые пути проекта, функции для работы с маршрутами и ресурсами, а также настройки производительности для загрузки файлов.

**Листинг 2.1 – Конфигурация путей и функций маршрутизации**

```php
// config/app.php

if (!defined('BASE_PATH')) {
    $projectRoot = str_replace('\\', '/', realpath(dirname(__DIR__)));
    define('BASE_PATH', $projectRoot);
}

if (!function_exists('route_path')) {
    function route_path(string $path = ''): string
    {
        $cleanPath = ltrim($path, '/');
        $base = BASE_URI;
        $prefix = $base === '' ? '' : $base;
        return rtrim($prefix, '/') . ($cleanPath === '' ? '' : '/' . $cleanPath);
    }
}

if (!function_exists('asset_path')) {
    function asset_path(string $path = ''): string
    {
        $cleanPath = ltrim($path, '/');
        $base = BASE_URI;
        $prefix = $base === '' ? '' : $base;
        return rtrim($prefix, '/') . ($cleanPath === '' ? '' : '/' . $cleanPath);
    }
}
```

Функция `route_path()` используется для генерации корректных URL-адресов страниц приложения, а `asset_path()` – для формирования путей к статическим ресурсам (изображения, стили, скрипты). Это обеспечивает кроссплатформенность и корректную работу на различных серверных конфигурациях.

Подключение к базе данных MySQL реализовано через PDO в файле `config/database.php`:

**Листинг 2.2 – Подключение к базе данных**

```php
// config/database.php

$host = 'localhost';
$dbname = 'excursion_platform';
$username = 'root';
$password = 'root';

try {
    $pdo = new PDO("mysql:host=$host;dbname=$dbname;charset=utf8", $username, $password);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
} catch(PDOException $e) {
    die("Ошибка подключения: " . $e->getMessage());
}
```

Настройка `PDO::ATTR_ERRMODE` в значение `PDO::ERRMODE_EXCEPTION` обеспечивает автоматическое выбрасывание исключений при возникновении ошибок базы данных, что упрощает отладку и обработку ошибок в приложении.

## Авторизация и регистрация пользователей

Одним из ключевых компонентов системы является механизм авторизации и регистрации пользователей. Данный функционал обеспечивает контроль доступа к системе и разграничение прав пользователей в зависимости от их роли: клиент (customer), гид (guide) или администратор платформы (admin).

Функционал авторизации и регистрации реализован в виде отдельного серверного модуля `includes/auth.php`, который может быть использован на различных страницах системы. Такой подход исключает дублирование кода и упрощает поддержку приложения.

### Процесс регистрации

Процесс регистрации предусматривает ввод пользователем персональных данных, таких как имя пользователя (username), полное имя (full_name), адрес электронной почты (email), пароль, тип пользователя (user_type) и телефон (phone). Для обеспечения безопасности хранения информации пароли не сохраняются в открытом виде. Перед записью в базу данных они подвергаются хэшированию с использованием алгоритма bcrypt, реализованного стандартной функцией `password_hash()` с параметром `PASSWORD_DEFAULT`. Данный алгоритм считается криптографически стойким и обеспечивает защиту от атак перебором (brute-force attacks).

**Листинг 3.1 – Реализация регистрации пользователя**

```php
// includes/auth.php

// РЕГИСТРАЦИЯ
if(isset($_POST['register'])) {
    $username = trim($_POST['username']);
    $email = trim($_POST['email']);
    $password = password_hash($_POST['password'], PASSWORD_DEFAULT);
    $full_name = trim($_POST['full_name']);
    $user_type = $_POST['user_type'];
    $phone = trim($_POST['phone']);

    try {
        // Проверяем, не занят ли username или email
        $stmt = $pdo->prepare("SELECT id FROM users WHERE username = ? OR email = ?");
        $stmt->execute([$username, $email]);
        
        if($stmt->fetch()) {
            $_SESSION['error'] = "Пользователь с таким именем или email уже существует";
            header('Location: ' . route_path('pages/register.php'));
            exit();
        }

        $stmt = $pdo->prepare("INSERT INTO users (username, email, password, full_name, user_type, phone) VALUES (?, ?, ?, ?, ?, ?)");
        $stmt->execute([$username, $email, $password, $full_name, $user_type, $phone]);
        
        $_SESSION['success'] = "Регистрация успешна! Теперь войдите в систему.";
        header('Location: ' . route_path('pages/login.php'));
        exit();
        
    } catch(PDOException $e) {
        $_SESSION['error'] = "Ошибка регистрации: " . $e->getMessage();
        header('Location: ' . route_path('pages/register.php'));
        exit();
    }
}
```

В коде регистрации используется подготовленное выражение (prepared statement) для проверки уникальности имени пользователя и email. Это предотвращает создание дублирующихся записей в базе данных. При обнаружении существующего пользователя система информирует об ошибке через сессионную переменную и перенаправляет на страницу регистрации.

### Процесс авторизации

После регистрации пользователь получает возможность авторизоваться в системе. При выполнении входа сервер извлекает хэш пароля из базы данных и сравнивает его с введённым значением с помощью функции `password_verify()`. В случае успешной проверки создаётся пользовательская сессия, в которой сохраняется идентификатор пользователя, его имя, роль, email и URL аватара (при наличии). На основании роли реализуется логика перенаправления в соответствующий раздел системы – личный кабинет клиента, личный кабинет гида или административную панель.

**Листинг 3.2 – Реализация авторизации пользователя**

```php
// includes/auth.php

// ВХОД В СИСТЕМУ
if(isset($_POST['login'])) {
    $username = trim($_POST['username']);
    $password = $_POST['password'];

    try {
        $stmt = $pdo->prepare("SELECT * FROM users WHERE username = ? OR email = ?");
        $stmt->execute([$username, $username]);
        $user = $stmt->fetch();

        if($user && password_verify($password, $user['password'])) {
            // Успешный вход
            $_SESSION['user_id'] = $user['id'];
            $_SESSION['username'] = $user['username'];
            $_SESSION['user_type'] = $user['user_type'];
            $_SESSION['full_name'] = $user['full_name'];
            $_SESSION['email'] = $user['email'];
            if($user['avatar_url']) {
                $_SESSION['avatar_url'] = $user['avatar_url'];
            }
            
            // Запоминаем пользователя если выбрано "Запомнить меня"
            if(isset($_POST['remember_me'])) {
                setcookie('user_id', $user['id'], time() + 86400 * 30, '/'); // 30 дней
            }
            
            $_SESSION['success'] = "Добро пожаловать, " . $user['full_name'] . "!";
            if($user['user_type'] === 'admin') {
                header('Location: ' . route_path('pages/admin/dashboard.php'));
            } elseif($user['user_type'] === 'guide') {
                header('Location: ' . route_path('pages/guide/dashboard.php'));
            } else {
                header('Location: ' . route_path('pages/customer/dashboard.php'));
            }
            exit();
            
        } else {
            $_SESSION['error'] = "Неверное имя пользователя или пароль!";
            header('Location: ' . route_path('pages/login.php'));
            exit();
        }
        
    } catch(PDOException $e) {
        $_SESSION['error'] = "Ошибка входа: " . $e->getMessage();
        header('Location: ' . route_path('pages/login.php'));
        exit();
    }
}
```

Использование сессионного механизма PHP позволяет поддерживать состояние авторизации между HTTP-запросами и защищать приватные разделы приложения от несанкционированного доступа. Система поддерживает функцию "Запомнить меня", которая устанавливает cookie с идентификатором пользователя на срок 30 дней для автоматического входа при последующих посещениях.

Авторизация по имени пользователя или email обеспечивает дополнительное удобство для пользователей, так как они могут использовать любой из этих идентификаторов для входа в систему.

## Просмотр и фильтрация экскурсий

Просмотр и фильтрация экскурсий являются основным способом взаимодействия пользователей с платформой. Система предоставляет возможность отображения списка доступных экскурсий с применением различных параметров фильтрации, таких как город проведения, тематика (категория), стоимость, длительность, дата создания и текстовая строка поиска.

Пользователям предоставляется возможность просматривать список доступных экскурсий, а также применять фильтры по различным критериям. Для реализации фильтрации используется клиентская логика на JavaScript, которая работает с данными, уже загруженными на страницу в виде HTML-карточек экскурсий. Каждая карточка содержит атрибуты `data-*`, которые хранят информацию о городе, категории, цене, длительности и других характеристиках экскурсии. Такой подход позволяет эффективно обрабатывать данные без необходимости дополнительных запросов к серверу при каждом изменении фильтров.

**Листинг 4.1 – SQL-запрос получения списка активных экскурсий**

```php
// pages/excursions.php

$stmt = $pdo->prepare("
    SELECT e.*, u.full_name as guide_name, u.avatar_url as guide_avatar_url
    FROM excursions e 
    JOIN users u ON e.guide_id = u.id 
    WHERE e.is_active = TRUE
    ORDER BY e.created_at DESC
");
$stmt->execute();
$excursions = $stmt->fetchAll();
```

SQL-запрос использует соединение таблиц `excursions` и `users` для получения информации об экскурсиях вместе с данными гида, который их проводит. Условие `WHERE e.is_active = TRUE` гарантирует отображение только активных экскурсий. Результаты упорядочиваются по дате создания в порядке убывания, чтобы новые экскурсии отображались первыми.

Для повышения удобства пользователя применяется асинхронная фильтрация на стороне клиента с использованием JavaScript. Это позволяет обновлять список экскурсий без полной перезагрузки страницы и делает интерфейс более отзывчивым. Фильтрация выполняется в реальном времени при изменении значений в полях фильтров с использованием функции debounce (задержка 300 миллисекунд) для оптимизации производительности.

**Листинг 4.2 – JavaScript-фрагмент фильтрации и сортировки экскурсий**

```javascript
// pages/excursions.php

function filterAndSort() {
    const cards = Array.from(document.querySelectorAll('.excursion-card'));
    const search = searchInput.value.toLowerCase();
    const city = cityFilter.value;
    const category = categoryFilter.value;
    const minPrice = parseFloat(priceMin.value) || 0;
    const maxPrice = parseFloat(priceMax.value) || Infinity;
    const minDuration = parseInt(durationMin.value) || 0;
    const maxDuration = parseInt(durationMax.value) || Infinity;
    
    let visibleCount = 0;
    
    // Фильтрация
    cards.forEach(card => {
        const title = card.dataset.title.toLowerCase();
        const description = card.dataset.description.toLowerCase();
        const cardCity = card.dataset.city;
        const cardCategory = card.dataset.category;
        const price = parseFloat(card.dataset.price);
        const duration = parseInt(card.dataset.duration);
        
        const matchesSearch = title.includes(search) || description.includes(search);
        const matchesCity = !city || cardCity === city;
        const matchesCategory = !category || cardCategory === category;
        const matchesPrice = price >= minPrice && price <= maxPrice;
        const matchesDuration = duration >= minDuration && duration <= maxDuration;
        
        if(matchesSearch && matchesCity && matchesCategory && matchesPrice && matchesDuration) {
            card.style.display = 'block';
            visibleCount++;
        } else {
            card.style.display = 'none';
        }
    });
    
    // Сортировка видимых карточек
    const visibleCards = cards.filter(card => card.style.display !== 'none');
    const sort = sortBy.value;
    
    visibleCards.sort((a, b) => {
        switch(sort) {
            case 'price_asc':
                return parseFloat(a.dataset.price) - parseFloat(b.dataset.price);
            case 'price_desc':
                return parseFloat(b.dataset.price) - parseFloat(a.dataset.price);
            case 'title_asc':
                return a.dataset.title.localeCompare(b.dataset.title, 'ru');
            case 'title_desc':
                return b.dataset.title.localeCompare(a.dataset.title, 'ru');
            case 'duration_asc':
                return parseInt(a.dataset.duration) - parseInt(b.dataset.duration);
            case 'duration_desc':
                return parseInt(b.dataset.duration) - parseInt(a.dataset.duration);
            case 'date_asc':
                return parseInt(a.dataset.created) - parseInt(b.dataset.created);
            case 'date_desc':
            default:
                return parseInt(b.dataset.created) - parseInt(a.dataset.created);
        }
    });
    
    // Перестраиваем DOM
    visibleCards.forEach(card => container.appendChild(card));
    
    // Показываем/скрываем сообщение "ничего не найдено"
    noResults.style.display = visibleCount === 0 ? 'block' : 'none';
}
```

Функция `filterAndSort()` выполняет комплексную фильтрацию по всем заданным критериям одновременно. Для текстового поиска используется метод `includes()`, который проверяет наличие введённой строки в названии или описании экскурсии. Фильтрация по городу и категории происходит через точное сравнение значений. Диапазоны цен и длительности проверяются на соответствие заданным границам.

Сортировка реализована через метод массива `sort()` с различными критериями сравнения. Для числовых значений (цена, длительность) используется арифметическое сравнение, для текстовых (название) – метод `localeCompare()` с указанием русской локали, что обеспечивает корректную сортировку с учётом особенностей кириллицы.

## Процесс бронирования экскурсий

Процесс бронирования является центральной бизнес-функцией платформы. Его реализация требует обеспечения целостности данных и предотвращения конфликтов при одновременном бронировании мест несколькими пользователями. Данная задача решается с использованием механизма транзакций базы данных и блокировки строк с помощью конструкции `FOR UPDATE`.

Перед созданием бронирования система проверяет, авторизован ли пользователь. Далее выполняется запрос к базе данных для получения информации о количестве доступных мест на выбранную дату экскурсии. Для предотвращения состояния гонки (race condition) используется механизм транзакций и блокировки строк базы данных с применением конструкции `FOR UPDATE` в SQL-запросе. Это гарантирует, что при одновременных попытках бронирования мест на одну и ту же дату только один запрос получит доступ к данным, а остальные будут ожидать завершения транзакции.

**Листинг 4.3 – Реализация транзакции бронирования экскурсии**

```php
// includes/process_booking.php

if($_SERVER['REQUEST_METHOD'] === 'POST') {
    $customer_id = $_SESSION['user_id'];
    $excursion_date_id = $_POST['excursion_date_id'] ?? null;
    $participants_count = (int)($_POST['participants_count'] ?? 0);
    $promo_code = trim($_POST['promo_code'] ?? '');

    if(!$excursion_date_id || $participants_count < 1) {
        $_SESSION['error'] = "Некорректные данные бронирования.";
        header('Location: ' . route_path('pages/booking.php') . '?excursion_id=' . ($_POST['excursion_id'] ?? ''));
        exit();
    }

    try {
        $pdo->beginTransaction();

        $stmt = $pdo->prepare("
            SELECT ed.*, e.price, e.guide_id, e.title, ed.available_slots, ed.excursion_id
            FROM excursion_dates ed 
            JOIN excursions e ON ed.excursion_id = e.id 
            WHERE ed.id = ? AND ed.is_available = TRUE
            FOR UPDATE
        ");
        $stmt->execute([$excursion_date_id]);
        $date_info = $stmt->fetch();

        if(!$date_info) {
            throw new Exception("Выбранная дата недоступна");
        }

        if($date_info['available_slots'] < $participants_count) {
            throw new Exception("Недостаточно доступных мест");
        }

        // Проверка минимального времени бронирования (24 часа)
        $excursion_datetime = strtotime($date_info['available_date'] . ' ' . $date_info['available_time']);
        $hours_until = ($excursion_datetime - time()) / 3600;
        
        if($hours_until < 24) {
            throw new Exception("Бронирование возможно не менее чем за 24 часа до начала экскурсии");
        }

        $base_price = $date_info['price'] * $participants_count;
        $discount = 0;

        // Обработка промо-кода
        if(!empty($promo_code)) {
            $stmt = $pdo->prepare("
                SELECT * FROM promo_codes 
                WHERE code = ? 
                  AND is_active = TRUE 
                  AND valid_until >= CURDATE() 
                  AND used_count < max_uses
                FOR UPDATE
            ");
            $stmt->execute([$promo_code]);
            $promo = $stmt->fetch();

            if($promo) {
                $discount = $base_price * ($promo['discount_percent'] / 100);
                $stmt = $pdo->prepare("UPDATE promo_codes SET used_count = used_count + 1 WHERE id = ?");
                $stmt->execute([$promo['id']]);
            } else {
                $_SESSION['error'] = "Промо-код недействителен.";
            }
        }

        $total_price = $base_price - $discount;

        // Создание записи о бронировании
        $stmt = $pdo->prepare("
            INSERT INTO orders (customer_id, excursion_date_id, participants_count, total_price, status) 
            VALUES (?, ?, ?, ?, 'pending')
        ");
        $stmt->execute([$customer_id, $excursion_date_id, $participants_count, $total_price]);

        // Уменьшение количества доступных мест
        $stmt = $pdo->prepare("UPDATE excursion_dates SET available_slots = available_slots - ? WHERE id = ?");
        $stmt->execute([$participants_count, $excursion_date_id]);

        $pdo->commit();

        $_SESSION['success'] = "Бронирование успешно создано! Ожидайте подтверждения от гида.";
    } catch(Exception $e) {
        $pdo->rollBack();
        $_SESSION['error'] = "Ошибка бронирования: " . $e->getMessage();
    }
}
```

При наличии достаточного количества свободных мест создаётся запись о бронировании со статусом «pending» (ожидание). Одновременно производится уменьшение количества доступных мест в таблице `excursion_dates`. Система также проверяет, что бронирование происходит не менее чем за 24 часа до начала экскурсии, что даёт гиду возможность подготовиться к проведению мероприятия.

Применение транзакционного подхода обеспечивает целостность данных и предотвращает ситуации, при которых количество проданных билетов превышает фактическое количество доступных мест. В случае возникновения любой ошибки в процессе бронирования выполняется откат транзакции (rollback), который возвращает базу данных в исходное состояние.

## Система промо-кодов

Для стимулирования продаж и повышения лояльности пользователей в системе реализован механизм промо-кодов. Каждый промо-код имеет уникальный код, процент скидки (discount_percent), период действия (valid_until), лимит использования (max_uses) и счётчик использований (used_count). Промо-коды могут быть активированы или деактивированы администратором через флаг `is_active`.

При вводе промо-кода система выполняет проверку его актуальности и корректности. Проверяются следующие условия: промо-код должен быть активным (`is_active = TRUE`), срок действия не должен истечь (`valid_until >= CURDATE()`), и количество использований не должно превышать лимит (`used_count < max_uses`). В случае успешной проверки производится перерасчёт итоговой стоимости бронирования с учётом скидки. Реализована защита от получения отрицательной стоимости заказа – скидка не может превышать базовую стоимость.

**Листинг 4.4 – Проверка и применение промо-кода**

```php
// includes/process_booking.php

if(!empty($promo_code)) {
    $stmt = $pdo->prepare("
        SELECT * FROM promo_codes 
        WHERE code = ? 
          AND is_active = TRUE 
          AND valid_until >= CURDATE() 
          AND used_count < max_uses
        FOR UPDATE
    ");
    $stmt->execute([$promo_code]);
    $promo = $stmt->fetch();

    if($promo) {
        $discount = $base_price * ($promo['discount_percent'] / 100);
        
        // Обновление счётчика использований промо-кода
        $stmt = $pdo->prepare("UPDATE promo_codes SET used_count = used_count + 1 WHERE id = ?");
        $stmt->execute([$promo['id']]);
        
        $total_price = $base_price - $discount;
    } else {
        $_SESSION['error'] = "Промо-код недействителен.";
    }
}
```

Использование конструкции `FOR UPDATE` при проверке промо-кода гарантирует, что при одновременных попытках использования одного промо-кода несколькими пользователями счётчик использований будет обновляться корректно, предотвращая превышение лимита использования.

Платформа также предоставляет REST-подобный API-эндпоинт для асинхронной проверки промо-кодов на стороне клиента. Это позволяет пользователю видеть применение скидки сразу после ввода кода без необходимости перезагрузки страницы.

**Листинг 4.5 – API-метод проверки промо-кода**

```php
// includes/apply_promo.php

header('Content-Type: application/json');
require_once 'config/database.php';

if($_SERVER['REQUEST_METHOD'] == 'POST') {
    $promo_code = $_POST['promo_code'];
    $total_price = $_POST['total_price'];

    try {
        $stmt = $pdo->prepare("
            SELECT * FROM promo_codes 
            WHERE code = ? AND is_active = TRUE 
            AND valid_until >= CURDATE() 
            AND used_count < max_uses
        ");
        $stmt->execute([$promo_code]);
        $promo = $stmt->fetch();

        if($promo) {
            echo json_encode([
                'success' => true,
                'discount_percent' => $promo['discount_percent'],
                'message' => 'Промо-код применен успешно'
            ]);
        } else {
            echo json_encode([
                'success' => false,
                'message' => 'Промо-код недействителен или истек'
            ]);
        }
    } catch(PDOException $e) {
        echo json_encode([
            'success' => false,
            'message' => 'Ошибка проверки промо-кода'
        ]);
    }
}
```

API возвращает ответ в формате JSON с информацией об успешности применения промо-кода и проценте скидки, что позволяет клиентской части динамически пересчитать итоговую стоимость бронирования.

## REST-подобный API

Для взаимодействия клиентской и серверной частей используется REST-подобный API. Все серверные маршруты размещены в отдельных файлах в каталоге `api/` и возвращают данные в формате JSON. Каждый маршрут отвечает за выполнение конкретной бизнес-операции, такой как получение списка доступных дат для экскурсии или проверка промо-кода.

**Листинг 4.6 – API-метод получения расписания экскурсии**

```php
// api/get_dates.php

header('Content-Type: application/json');
require_once '../config/database.php';

if(isset($_GET['excursion_id'])) {
    $excursion_id = $_GET['excursion_id'];
    
    $stmt = $pdo->prepare("
        SELECT * FROM excursion_dates 
        WHERE excursion_id = ? AND is_available = TRUE 
        AND available_slots > 0 
        AND available_date >= CURDATE()
        ORDER BY available_date, available_time
    ");
    $stmt->execute([$excursion_id]);
    $dates = $stmt->fetchAll(PDO::FETCH_ASSOC);
    
    echo json_encode($dates);
}
```

Данный API-эндпоинт возвращает список доступных дат для указанной экскурсии. Запрос фильтрует только те даты, которые доступны для бронирования (`is_available = TRUE`), имеют свободные места (`available_slots > 0`) и находятся в будущем (`available_date >= CURDATE()`). Результаты упорядочиваются по дате и времени проведения экскурсии.

Чёткое разделение маршрутов повышает читаемость кода и упрощает дальнейшее расширение функционала системы. Доступ к административным маршрутам ограничен ролевой моделью доступа через проверку типа пользователя в сессии.

## Клиентская логика и пользовательский интерфейс

Клиентская логика системы реализована с использованием языка JavaScript. Асинхронные запросы позволяют динамически загружать данные о датах и временных слотах экскурсий без перезагрузки страницы. Это значительно улучшает пользовательский опыт, делая интерфейс более отзывчивым и интерактивным.

Интерфейс системы разработан с учётом принципов удобства использования (usability) и адаптивного дизайна, что обеспечивает корректную работу приложения на различных устройствах – от настольных компьютеров до мобильных телефонов. Использование CSS Grid и Flexbox обеспечивает гибкую компоновку элементов интерфейса, а медиа-запросы позволяют адаптировать макет под различные размеры экранов.

Формы ввода данных, такие как форма бронирования или форма редактирования профиля, используют валидацию как на стороне клиента (HTML5 атрибуты `required`, `type`, `min`, `max`), так и на стороне сервера (проверка данных в PHP перед сохранением в базу данных). Это обеспечивает двойную защиту от некорректных данных и улучшает пользовательский опыт за счёт мгновенной обратной связи.

Личный кабинет пользователей реализован в виде модульного интерфейса с разделением на вкладки. Для клиентов доступны вкладки "Профиль", "Мои заказы" и "Избранное". Для гидов предусмотрены вкладки "Профиль", "Мои экскурсии" и "Бронирования". Администраторы имеют доступ к панели управления с общей статистикой платформы и возможностью управления пользователями, экскурсиями и заказами.

Система поддерживает загрузку аватаров пользователей с валидацией типа файла (разрешены изображения в форматах JPG, PNG, GIF, WEBP) и размера (максимальный размер 5 МБ). Загруженные файлы сохраняются в каталоге `uploads/avatars/` с уникальными именами для предотвращения конфликтов при одновременной загрузке файлов разными пользователями.

**Листинг 4.7 – Загрузка аватара пользователя**

```php
// includes/upload_avatar.php

if($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES['avatar'])) {
    $user_id = $_SESSION['user_id'];
    $uploadDir = base_path('uploads/avatars');
    $publicUploadPrefix = 'uploads/avatars/';
    $maxUploadSize = 5 * 1024 * 1024; // 5 МБ

    if(!is_dir($uploadDir)) {
        mkdir($uploadDir, 0777, true);
    }

    $allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
    $file = $_FILES['avatar'];

    try {
        if($file['error'] !== UPLOAD_ERR_OK) {
            throw new RuntimeException('Ошибка загрузки файла: ' . $file['error']);
        }

        if($file['size'] > $maxUploadSize) {
            throw new RuntimeException('Размер файла превышает 5 МБ');
        }

        $finfo = new finfo(FILEINFO_MIME_TYPE);
        $mimeType = $finfo->file($file['tmp_name']);
        if (!in_array($mimeType, $allowedTypes)) {
            throw new RuntimeException('Недопустимый тип файла. Разрешены только JPG, PNG, GIF, WEBP.');
        }

        // Получаем текущий аватар пользователя
        $stmt = $pdo->prepare("SELECT avatar_url FROM users WHERE id = ?");
        $stmt->execute([$user_id]);
        $user = $stmt->fetch();
        $oldAvatar = $user['avatar_url'] ?? null;

        // Генерируем уникальное имя файла
        $extension = pathinfo($file['name'], PATHINFO_EXTENSION);
        $filename = 'avatar_' . $user_id . '_' . time() . '_' . uniqid() . '.' . $extension;
        $fullPath = $uploadDir . DIRECTORY_SEPARATOR . $filename;

        // Загружаем файл
        if(!move_uploaded_file($file['tmp_name'], $fullPath)) {
            throw new RuntimeException('Не удалось сохранить файл');
        }

        // Обновляем БД
        $avatarUrl = $publicUploadPrefix . $filename;
        $stmt = $pdo->prepare("UPDATE users SET avatar_url = ? WHERE id = ?");
        $stmt->execute([$avatarUrl, $user_id]);

        // Удаляем старый аватар
        if($oldAvatar && file_exists(base_path($oldAvatar))) {
            @unlink(base_path($oldAvatar));
        }

        $_SESSION['success'] = "Аватар успешно обновлен!";
        $_SESSION['avatar_url'] = $avatarUrl;

    } catch (RuntimeException $e) {
        $_SESSION['error'] = $e->getMessage();
    } catch (PDOException $e) {
        $_SESSION['error'] = "Ошибка базы данных: " . $e->getMessage();
    }
}
```

Код загрузки аватара включает комплексную валидацию: проверку ошибок загрузки, размера файла и MIME-типа через библиотеку `fileinfo`. Генерация уникального имени файла предотвращает перезапись существующих файлов и конфликты при одновременной загрузке. После успешной загрузки новый файл сохраняется на сервере, база данных обновляется, а старый аватар (при его наличии) удаляется для экономии дискового пространства.

## База данных

Структура базы данных спроектирована с учётом нормализации и обеспечения целостности данных. Основные таблицы системы:

- **users** – хранит информацию о пользователях (клиентах, гидах, администраторах)
- **excursions** – содержит данные об экскурсиях
- **excursion_dates** – расписание доступных дат и времени проведения экскурсий
- **orders** – записи о бронированиях экскурсий
- **promo_codes** – промо-коды для применения скидок
- **favorites** – избранные экскурсии пользователей
- **reviews** – отзывы клиентов об экскурсиях

Между таблицами установлены внешние ключи (FOREIGN KEY) с каскадным удалением (ON DELETE CASCADE), что обеспечивает автоматическое удаление связанных записей при удалении родительской записи. Например, при удалении экскурсии автоматически удаляются все связанные записи о датах проведения и заказах.

**Листинг 4.8 – Структура таблицы экскурсий**

```sql
-- sql/database_schema.sql

CREATE TABLE IF NOT EXISTS excursions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    guide_id INT NOT NULL,
    title VARCHAR(200) NOT NULL,
    description TEXT NOT NULL,
    short_description TEXT,
    city VARCHAR(100) NOT NULL,
    address TEXT,
    duration INT NOT NULL COMMENT 'Продолжительность в минутах',
    price DECIMAL(10,2) NOT NULL,
    max_participants INT NOT NULL,
    category VARCHAR(50) NOT NULL,
    meeting_point TEXT,
    image_url VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (guide_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_city (city),
    INDEX idx_category (category),
    INDEX idx_is_active (is_active),
    INDEX idx_guide_id (guide_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

Использование индексов на часто используемых полях (city, category, is_active, guide_id) значительно повышает производительность запросов при фильтрации и поиске экскурсий. Движок InnoDB обеспечивает поддержку транзакций и внешних ключей, что критично для обеспечения целостности данных при бронировании.

## Заключение

Разработанная платформа бронирования экскурсий представляет собой полнофункциональную веб-систему, реализующую основные бизнес-процессы организации и продажи экскурсий. Применение современных технологий веб-разработки, таких как PDO для безопасной работы с базой данных, сессии PHP для управления состоянием пользователей, транзакции для обеспечения целостности данных и асинхронные запросы для улучшения пользовательского опыта, обеспечивает высокую надёжность, безопасность и удобство использования системы.

Модульная архитектура проекта облегчает поддержку и дальнейшее расширение функционала. Разделение на конфигурацию, серверную логику, API, пользовательский интерфейс и ресурсы способствует повышению качества кода и упрощению процесса разработки. Реализованная система авторизации с хэшированием паролей, механизм бронирования с транзакциями и блокировками, а также поддержка промо-кодов и загрузки файлов демонстрируют применение лучших практик веб-разработки для создания безопасных и производительных приложений.




